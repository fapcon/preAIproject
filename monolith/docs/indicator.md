# Техническое задание для разработки микросервиса предоставления данных по биржевым индикаторам

## 1. Введение

Целью данного проекта является разработка микросервиса, который предоставляет данные по различным биржевым индикаторам. Микросервис должен иметь механизм кеширования данных с использованием Redis. Сервис должен предоставлять данные посредством REST API запросов.

Микросервис разрабатывается как публичный сервис без авторизации пользователей, с возможностью добавления авторизации в будущем, если потребуется. Основной задачей микросервиса является предоставление актуальных данных по следующим индикаторам: **RSI**, **Stochastic RSI**, **CCI**, **Bollinger Bands**, **EMA**, **SMA**, **MACD** в определенных временных интервалах (`timeframe`) и за определенный период времени (`window`), заданных при запросе.

## 2. Функциональные требования

### 2.1 REST API

#### 1. Получение текущих данных по индикаторам:
- URL: `/indicators`
- Метод: `GET`
- Параметры запроса (пример для RSI на бирже **Bybit**):
  - `exchangeID` (`int`, обязательный) – идентификатор биржи (например, `1` для Bybit).
  - `symbol` (`string`, обязательный) - символ валютной пары (например, `BTCUSDT`).
  - `timeframe` (`string`, обязательный) - временной интервал (например, `5m`, `30m`, `1h`, `4h`, `1d`).
  - `indicator` (`string`, обязательный) - выбранный индикатор (например, `RSI`).
  - `window` (`int`, обязательный) – выбранный интервал (например, `14`).

#### 2. Получение данных временных рядов по индикаторам за указанный период (стандартный набор параметров):
- URL: `/indicators/series`
- Метод: `GET`
- Параметры запроса (пример для RSI на бирже **Bybit**):
  - `exchangeID` (`int`, обязательный) – идентификатор биржи (например, `1` для Bybit).
  - `symbol` (`string`, обязательный) - символ валютной пары (например, `BTCUSDT`).
  - `timeframe` (`string`, обязательный) - временной интервал (например, `5m`, `30m`, `1h`, `4h`, `1d`).
  - `indicator` (`string`, обязательный) - выбранный индикатор (например, `RSI`).
  - `window` (`int`, обязательный) – выбранный интервал (например, `14`).
  - `startTime` (`int`, обязательный) - время начала периода в формате UNIX.
  - `endTime` (`int`, необязательный) - время окончания периода в формате UNIX (при отсутствии - текущее время).

#### 3. Запрос данных о доступных индикаторах
- URL: `/indicators/available`
- Метод: `GET`

#### 4. Запрос данных о доступных валютных парах
- URL: `/indicators/symbols`
- Метод: `GET`

### 2.2 Хранилище данных

- Необходимо разработать механизм хранения данных по свечам в Redis кэше. Эти данные должны содержать цену открытия, закрытия, максимума, минимума и объем торгов для каждой свечи на разных временных интервалах. Данные должны представлять собой непрерывную во времени последовательность свечей, достаточную для вычисления любого из поддерживаемых индикаторов.
- При получении запроса на расчет индикаторов, микросервис сначала будет проверять наличие данных по свечам в кэше для запрошенного символа и временного интервала. Если данные уже есть в кэше, они могут быть использованы для вычисления значения индикаторов без необходимости делать запросы к бирже.
- Если данных в кэше нет или они устарели, микросервис должен запросить свежие данные по свечам у биржи, вычислить значения запрошенных индикаторов и сохранить полученные данные по свечам в кэше для будущих запросов.
- Необходимо обеспечить механизм обновления данных в кэше с учетом разумного периода хранения данных свечей.
- **Примечание**: _Несмотря на то, что существует огромное количество комбинаций параметров при вычислении индикаторов, возможно, стоит рассмотреть необходимость сохранения результатов вычисления наиболее востребованных наборов конфигураций в базе данных PostgreSQL или Prometheus для последующего анализа. Например, для вычисления RSI обычно используют параметр window равный 14. Возможно, имеет смысл сохранять в базе изменение этого и других индикаторов во времени на некоторых таймфреймах с набором параметров, используемых в торговых стратегиях._

### 2.3 Защита и безопасность

#### 1. HTTPS:
- Использовать HTTPS для защиты передачи данных по сети.

#### 2. Rate Limiting:
- Реализовать механизм Rate Limiting для предотвращения атак на сервис.

Пример реализации:
```go
import (
"github.com/go-chi/chi/v5"
"github.com/go-chi/throttle/v2"
)
```
```go
r := chi.NewRouter()

throttle := throttle.New(throttle.PerMin(100))

r.Use(throttle.Handler)

r.Get("/indicators", func(w http.ResponseWriter, r *http.Request) {
// ... код обработки запроса
})
```

#### 3. Дополнительные мероприятия по безопасности:
- Введение белых списков:

Использовать белые списки IP-адресов или запросов, которые имеют приоритет и не подвержены Rate Limiting.

- Мониторинг атак:

Использовать систему мониторинга, которая будет определять необычную активность, такую как множественные запросы с одного IP-адреса, и оповещать администраторов.

- Автоматическая блокировка:

Реализовать автоматическую блокировку IP-адресов, которые систематически нарушают лимиты Rate Limiting.

### 2.4. Мониторинг и метрики

Внедрить интеграцию с Prometheus для сбора метрик. Записывать метрики по следующим параметрам:

- Количество запросов к API.
- Время обработки запросов.
- Статусы запросов (успешные, ошибки).
- Использование кэша.
### 2.5. Обработка ошибок
При возникновении ошибок в API-запросах, микросервис должен возвращать соответствующий HTTP статус код, например, 400 Bad Request для ошибок в запросе, 404 Not Found для отсутствующих ресурсов и 500 Internal Server Error для внутренних ошибок сервера.

Все ответы API должны быть структурированными JSON объектами. Эти объекты должны содержать информацию о возникшей ошибке, включая код ошибки и описание.
```json
{
  "error":{
    "code":400,
    "message":"Invalid request parameters"
  }
}
```
Также необходимо внедрить систему мониторинга, которая будет следить за записями в соответствующих журналах и оповещать администраторов о необычной активности, такой как несколько ошибок за короткий промежуток времени.

## 3. Технические требования
### 3.2 Кеширование
- Использовать Redis для кеширования данных.
### 3.3 Фреймворк
- Использовать фреймворк go-chi для разработки RESTful API.
### 3.4 Мониторинг
- Интегрировать Prometheus для сбора метрик.