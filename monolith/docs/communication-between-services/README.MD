# Коммуникация между микросервисами

## GRPC
gRPC (Remote Procedure Call) - это высокопроизводительная система для удаленного вызова процедур, разработанная компанией Google. Она использует протокол HTTP/2 для передачи данных и протокол бинарной сериализации Protobuf для кодирования сообщений.

GRPC позволяет разработчикам создавать клиент-серверные приложения, которые могут работать на разных языках программирования и платформах.

Преимущества GRPC:

1. буферы протокола (Protobuf) вместо JSON.
2. HTTP 2 вместо HTTP 1.1.
3. встроенная генерация кода.
4. высокая производительность.
5. SSL-защита.

В gRPC есть четыре типа API:

- Унарный.
Очень похож на традиционный API (REST API): клиент делает запрос, а сервер отправляет ответ.

- Потоковой передачи данных с сервера.
Здесь клиент делает один запрос, а сервер отправляет несколько или поток данных.

- Потоковой передачи данных от клиента.
То же, что предыдущий, но наоборот: клиент отправляет поток данных, а сервер — один ответ.

- Двунаправленной потоковой передачи.
Здесь клиент и сервер отправляют потоки данных.

gRPC идеально подойдет для внутренних задач:

- связывания микросервисов;
- потоковой передачи данных в режиме реального времени;
- многоязычных систем.

## План внедрения в проект:

***Пакет со сгенерированным кодом подлежит строгому версионированию по semver!***

> Далее идут примеры кода.

1. Описать .proto файл.
```protobuf
syntax = "proto3";

option go_package="example";
package example;

service User_service {
  rpc Create(example) returns (example){}
}

message example {
  string field = 1;
}

```
2. Сгенерировать код с помощью компилятора protoc:
- генерация кода для создания клиента и сервера:
```shell
protoc -I --grpc_go_out=/generated/ path/to/your/service.proto
```
- генерация кода для сериализации/десериализации сообщений:
```shell
protoc -I --go_out/generated/ path/to/your/service.proto
```
3. Имплементировать методы для grpc:
```go
func (e *exampleStruct) Create(ctx context.Context, in *exampleIn) (*exampleOut, error) {
	var out exampleOut
	out = e.exampleStruct.Create(ctx, e.service.Create(in.GetField())
	return &exampleOut{Field: out.Field}, nil
}
```
4. Далее необходимо на стороне сервера создать и зарегестрировать grpc-сервер:
```go
func initGrpcServer() {
	exampleService := service.NewExampleService(exampleStorageLayer)
	grpcServer := grpc.NewServer()
	grpc_example.RegisterExampleServiceServer(grpcServer, exampleService)
	
	listen, _ := net.Listen("tcp", "9999")
	grpcServer.Serve(listen)
}
```
5. **Обязательно при изменении сгенерированного кода при коммите указывать следующий git tag согласно semver!**
   
Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:

- МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
- МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной совместимости.
- ПАТЧ-версию, когда вы делаете обратно совместимые исправления.

#### Пример:
- Легковесный тег:
```shell
git tag v1.4.0
```
 
- Аннотированный тег (рекомендуется оф. документацией git-a):
```shell
git tag -a v1.4.0 -m "my version 1.4.0"
```
## Плюсы и минусы
| Плюсы                                                     | Минусы                                         |
|-----------------------------------------------------------|------------------------------------------------|
| Асинхронная передача данных                               | Более долгая реализация                        |
| Более безопасен, чем RESTlike подход                      | Требуется определенный уровень тех. экспертизы |
| .proto файл можно написать один раз и использовать везде  |                                                |